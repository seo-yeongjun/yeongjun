<!DOCTYPE html>
<html xmlns:layout="http://www.ultraq.net.nz/web/thymeleaf/layout"
      layout:decorate="~{coffeeGame/layout}">
<head>
    <title th:text="'ì˜ì¤€ë‹·ì»´ | ì»¤í”¼ê²Œì„-ì‚¬ë‹¤ë¦¬íƒ€ê¸°'"></title>
    <style>
        /* ëª¨ë°”ì¼ ëŒ€ì‘ */
        @media (max-width: 768px) {
            .input-container {
                flex-direction: column;
                gap: 1rem;
            }
            #nameList, #resultList {
                width: 100% !important;
                padding: 0 !important;
            }
        }
    </style>
</head>
<body>
<div layout:fragment="content">
    <!-- ì˜¤ë¥˜ ë©”ì‹œì§€ -->
    <div id="errorMsg"
         role="alert"
         aria-live="assertive"
         class="text-red-500 mb-2 hidden"></div>

    <!-- ì„¤ì • ì˜ì—­ -->
    <div id="settingBoard" class="container mx-auto py-8">
        <div class="flex justify-center">
            <div class="bg-white p-4 rounded-lg shadow-md w-full max-w-md flex flex-col items-center">
                <div class="mb-10 w-full bg-[aliceblue] p-4 rounded">
                    <h1 class="text-2xl font-bold mb-4">ì‚¬ë‹¤ë¦¬ ê²Œì„</h1>
                    <p class="text-gray-700 mb-4">ì°¸ê°€ì ìˆ˜ë¥¼ ì„¤ì •í•˜ê³ , ê°ì ë™ë¬¼ì„ ê³¨ë¼ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!</p>
                    <p class="text-gray-500 text-sm">â€» ì‚¬ë‹¤ë¦¬íƒ€ê¸° ê²Œì„ì€ ëœë¤ìœ¼ë¡œ ê²°ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</p>
                </div>
                <div class="flex items-center space-x-2 mb-4">
                    <label for="playerCount" class="font-medium text-gray-700">ì°¸ê°€ì ìˆ˜</label>
                    <button id="minusBtn"
                            class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 focus:outline-none"
                            aria-label="ì°¸ê°€ì ìˆ˜ ê°ì†Œ" tabindex="0">âˆ’</button>
                    <input type="number" id="playerCount"
                           class="w-16 text-center border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                           value="4" min="1" max="10"
                           aria-label="ì°¸ê°€ì ìˆ˜ ì…ë ¥" tabindex="0">
                    <button id="plusBtn"
                            class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 focus:outline-none"
                            aria-label="ì°¸ê°€ì ìˆ˜ ì¦ê°€" tabindex="0">ï¼‹</button>
                </div>

                <div id="labelArea" class="hidden w-full">
                    <div class="flex justify-between input-container">
                        <div id="nameList" class="flex flex-col items-center space-y-2 w-1/2 pr-2"></div>
                        <div id="resultList" class="flex flex-col items-center space-y-2 w-1/2 pl-2"></div>
                    </div>
                </div>

                <div id="gameBtnArea" class="mt-4 hidden">
                    <button id="startGame"
                            class="bg-green-500 text-white px-4 py-1 rounded hover:bg-green-600 focus:outline-none"
                            aria-label="ê²Œì„ ì‹œì‘" tabindex="0">
                        ê²Œì„ ì‹œì‘
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- ê²Œì„ ë³´ë“œ -->
    <div id="gameBoard" class="md:max-w-[82vw] hidden mx-auto mt-4 bg-white rounded-lg shadow-md">
        <div class="flex justify-center mb-4">
            <button id="resetGame"
                    class="bg-red-500 text-white px-4 py-1 rounded hover:bg-red-600 focus:outline-none"
                    aria-label="ì´ˆê¸°í™”" tabindex="0" disabled>
                ì´ˆê¸°í™”
            </button>
        </div>
        <div class="overflow-x-auto">
            <canvas id="gameCanvas"
                    class="mx-auto h-[50vh] border border-gray-300"
                    tabindex="0"
                    aria-label="ì‚¬ë‹¤ë¦¬ ê²Œì„ ë³´ë“œ"></canvas>
        </div>
    </div>

    <script>
        window.onload = function() {
            // DOM ìš”ì†Œ
            const errorMsg         = document.getElementById('errorMsg');
            const minusBtn         = document.getElementById('minusBtn');
            const plusBtn          = document.getElementById('plusBtn');
            const playerCountInput = document.getElementById('playerCount');
            const nameList         = document.getElementById('nameList');
            const resultList       = document.getElementById('resultList');
            const labelArea        = document.getElementById('labelArea');
            const gameBtnArea      = document.getElementById('gameBtnArea');
            const startGameBtn     = document.getElementById('startGame');
            const resetGameBtn     = document.getElementById('resetGame');
            const settingBoard     = document.getElementById('settingBoard');
            const gameBoard        = document.getElementById('gameBoard');
            const gameCanvas       = document.getElementById('gameCanvas');

            // Offscreen ìº”ë²„ìŠ¤
            const offscreen = document.createElement('canvas');
            let octx;

            // ë Œë”ë§ ìƒíƒœ
            let ctx, canvasWidth, canvasHeight;
            let cols = 0, nameBoxes = [];
            let ladderMap = [], drawnPaths = [], animatingPaths = [];
            let animationRunning = false, lastFrameTime = 0;

            // í´ë¦­ëœ ì¹¸ ê¸°ë¡
            const clickedIndices = new Set();

            // ìƒìˆ˜
            const rowCount        = 15;
            const ANIMATION_SPEED = 0.3;
            const FRAME_INTERVAL  = 1000 / 60;
            const topMargin       = 50, bottomMargin = 50;
            const baseFontSize    = 16;
            const lineColor       = '#999', lineWidth = 2;
            const pathColors      = ['#FF6B6B','#0421e1','#f3de06','#cf01e8','#0baa00','#fb0000','#9B59B6','#3498DB'];
            let colorIndex        = 0;
            const animalNames     = ['ì‚¬ì','í˜¸ë‘ì´','ì½”ë¼ë¦¬','ê¸°ë¦°','ì—¬ìš°','ëŠ‘ëŒ€','ì›ìˆ­ì´','í† ë¼','íŒë‹¤','í­ê·„',
                'ì½”ì•Œë¼','ëŒê³ ë˜','ê³ ë˜','ì•…ì–´','ê±°ë¶ì´','ë¶€ì—‰ì´','ë¹„ë‘˜ê¸°','ë…ìˆ˜ë¦¬','ì½”ë¿”ì†Œ',
                'í•˜ë§ˆ','ë‚™íƒ€','ì–‘','ì—¼ì†Œ','ì†Œ','ë§','ë¼ì§€','ë‹­','ì˜¤ë¦¬','ê°œ','ìƒì–´'];
            const animalIcons     = ['ğŸ¦','ğŸ¯','ğŸ˜','ğŸ¦’','ğŸ¦Š','ğŸº','ğŸµ','ğŸ°','ğŸ¼','ğŸ§',
                'ğŸ¨','ğŸ¬','ğŸ‹','ğŸŠ','ğŸ¢','ğŸ¦‰','ğŸ¦','ğŸ¦…','ğŸ¦',
                'ğŸ¦›','ğŸ«','ğŸ‘','ğŸ','ğŸ„','ğŸ','ğŸ–','ğŸ“','ğŸ¦†','ğŸ¶','ğŸ¦ˆ'];

            // ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ/ìˆ¨ê¸°ê¸°
            function showError(msg) {
                errorMsg.textContent = msg;
                errorMsg.classList.remove('hidden');
            }
            function clearError() {
                errorMsg.classList.add('hidden');
            }

            // ì…ë ¥ë€ ìƒì„±
            function updateInputs(count) {
                labelArea.classList.remove('hidden');
                gameBtnArea.classList.remove('hidden');
                nameList.innerHTML   = '<label class="font-medium text-gray-700">í”Œë ˆì´ì–´ ì´ë¦„</label>';
                resultList.innerHTML = '<label class="font-medium text-gray-700">ê²°ê³¼</label>';

                for (let i = 0; i < count; i++) {
                    const inp = document.createElement('input');
                    inp.type = 'text';
                    inp.value = animalNames[i] ?? `í”Œë ˆì´ì–´${i+1}`;
                    inp.className = 'w-full border rounded px-2 py-1 focus:ring-2 focus:ring-blue-500';
                    inp.setAttribute('aria-label', `í”Œë ˆì´ì–´ ${i+1} ì´ë¦„`);
                    inp.tabIndex = 0;
                    inp.addEventListener('input', clearError);
                    nameList.appendChild(inp);
                }
                for (let i = 0; i < count; i++) {
                    const r = document.createElement('input');
                    r.type = 'text';
                    r.value = (i === Math.floor(count/2)) ? 'X' : 'O';
                    r.className = 'w-full border rounded px-2 py-1 focus:ring-2 focus:ring-blue-500';
                    r.setAttribute('aria-label', `í”Œë ˆì´ì–´ ${i+1} ê²°ê³¼`);
                    r.tabIndex = 0;
                    r.addEventListener('input', clearError);
                    resultList.appendChild(r);
                }
            }

            minusBtn.addEventListener('click', () => {
                let cnt = +playerCountInput.value - 1;
                if (cnt < 1) cnt = 1;
                playerCountInput.value = cnt;
                updateInputs(cnt);
            });
            plusBtn.addEventListener('click', () => {
                let cnt = +playerCountInput.value + 1;
                playerCountInput.value = cnt;
                updateInputs(cnt);
            });

            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (High-DPI + Offscreen)
            function initCanvas(widthPx) {
                const dpr = window.devicePixelRatio || 1;
                const heightCss = window.innerHeight * 0.5;
                ctx = gameCanvas.getContext('2d');
                gameCanvas.style.width  = `${widthPx}px`;
                gameCanvas.style.height = `${heightCss}px`;
                gameCanvas.width  = widthPx * dpr;
                gameCanvas.height = heightCss * dpr;
                ctx.scale(dpr, dpr);

                offscreen.width  = widthPx * dpr;
                offscreen.height = heightCss * dpr;
                octx = offscreen.getContext('2d');
                octx.scale(dpr, dpr);

                canvasWidth  = widthPx;
                canvasHeight = heightCss;
            }

            // ì‚¬ë‹¤ë¦¬ ë§µ ìƒì„±
            function initLadder(count) {
                cols = count;
                ladderMap = [];
                for (let r = 0; r < rowCount; r++) {
                    const row = new Array(count - 1).fill(false);
                    for (let c = 0; c < count - 1; c++) {
                        if (c > 0 && row[c - 1]) continue;
                        row[c] = Math.random() < 0.4;
                    }
                    ladderMap.push(row);
                }
            }

            // ì‚¬ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
            function drawLadder(c) {
                const usableH = canvasHeight - topMargin - bottomMargin;
                const gapY = usableH / (rowCount + 1);
                const gapX = canvasWidth / (cols + 1);
                c.strokeStyle = lineColor;
                c.lineWidth = lineWidth;
                for (let i = 1; i <= cols; i++) {
                    c.beginPath();
                    c.moveTo(gapX * i, topMargin);
                    c.lineTo(gapX * i, canvasHeight - bottomMargin);
                    c.stroke();
                }
                ladderMap.forEach((row, r) => {
                    const y = topMargin + gapY * (r + 1);
                    row.forEach((has, ci) => {
                        if (!has) return;
                        c.beginPath();
                        c.moveTo(gapX * (ci + 1), y);
                        c.lineTo(gapX * (ci + 2), y);
                        c.stroke();
                    });
                });
            }

            // ì´ë¦„ ê·¸ë¦¬ê¸°
            function drawNames(c, names, activeIndex = -1) {
                const gapX = canvasWidth / (cols + 1);
                const padX = 12, padY = 6;
                nameBoxes = [];
                names.forEach((t, i) => {
                    // í°íŠ¸ ì„¤ì •
                    c.font = `500 ${baseFontSize}px sans-serif`;
                    c.textAlign = 'center';
                    c.textBaseline = 'middle';

                    // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •
                    const textW = c.measureText(t).width;
                    const w = textW + padX * 2;
                    const h = baseFontSize + padY * 2;
                    const radius = h / 2;           // ë†’ì´ ì ˆë°˜ìœ¼ë¡œ ì™„ì „í•œ pill ëª¨ì–‘
                    const xC = gapX * (i + 1);
                    const y = topMargin - h - 10;
                    const x = xC - w / 2;

                    // ë²„íŠ¼ ë°°ê²½
                    c.save();
                    // í´ë¦­ëœ ë²„íŠ¼ì´ë©´ ì•½ê°„ ì–´ë‘ìš´ ë°°ê²½
                    c.fillStyle = (i === activeIndex) ? '#e0e0e0' : '#ffffff';
                    // ì•„ì£¼ ë¯¸ì„¸í•œ ê·¸ë¦¼ì
                    c.shadowColor = 'rgba(0,0,0,0.08)';
                    c.shadowBlur = 2;
                    c.shadowOffsetX = 0;
                    c.shadowOffsetY = 1;
                    // pill ëª¨ì–‘
                    c.beginPath();
                    c.moveTo(x + radius, y);
                    c.arcTo(x + w, y,     x + w, y + h, radius);
                    c.arcTo(x + w, y + h, x,     y + h, radius);
                    c.arcTo(x,     y + h, x,     y,     radius);
                    c.arcTo(x,     y,     x + w, y,     radius);
                    c.closePath();
                    c.fill();
                    c.restore();

                    // í…Œë‘ë¦¬
                    c.strokeStyle = '#dddddd';
                    c.lineWidth = 1;
                    c.stroke();

                    // í…ìŠ¤íŠ¸
                    c.fillStyle = '#333333';
                    c.fillText(t, xC, y + h / 2);

                    // ë²„íŠ¼ ì˜ì—­ ì €ì¥
                    nameBoxes.push({ x1: x, y1: y, x2: x + w, y2: y + h, colIndex: i });
                });
            }
            // ê²°ê³¼ ê·¸ë¦¬ê¸°
            function drawResults(c, results) {
                const gapX = canvasWidth / (cols + 1);
                c.font = `${baseFontSize}px sans-serif`;
                c.textAlign = 'center';
                c.textBaseline = 'top';
                results.forEach((t, i) => {
                    c.fillText(t, gapX * (i + 1), canvasHeight - bottomMargin + 5);
                });
            }

            // ì •ì  ìš”ì†Œ Offscreenì— ë¯¸ë¦¬ ê·¸ë¦¬ê¸°
            function drawStatic(names, results) {
                octx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawLadder(octx);
                drawNames(octx, names);
                drawResults(octx, results);
            }

            // ê²½ë¡œ ê³„ì‚°
            function getPathPoints(startCol) {
                const pts = [];
                const usableH = canvasHeight - topMargin - bottomMargin;
                const gapY = usableH / (rowCount + 1);
                const gapX = canvasWidth / (cols + 1);
                let c = startCol, x = gapX * (c + 1), y = topMargin;
                pts.push({ x, y });
                for (let r = 0; r < rowCount; r++) {
                    y = topMargin + gapY * (r + 1);
                    pts.push({ x, y });
                    if (c > 0 && ladderMap[r][c - 1]) {
                        x -= gapX; pts.push({ x, y }); c--;
                    } else if (c < cols - 1 && ladderMap[r][c]) {
                        x += gapX; pts.push({ x, y }); c++;
                    }
                }
                pts.push({ x, y: canvasHeight - bottomMargin });
                return { path: pts, finalCol: c };
            }

            // ì• ë‹ˆë©”ì´ì…˜
            function animateFrame(ts) {
                if (!lastFrameTime) lastFrameTime = ts;
                if (ts - lastFrameTime < FRAME_INTERVAL) {
                    if (animationRunning) requestAnimationFrame(animateFrame);
                    return;
                }
                // 1) ì •ì  ë³µì‚¬
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(offscreen, 0, 0, canvasWidth, canvasHeight);

                // 2) í™•ì •ëœ ê²½ë¡œ + ì•„ì´ì½˜
                drawnPaths.forEach(o => {
                    ctx.strokeStyle = o.color; ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(o.path[0].x, o.path[0].y);
                    o.path.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.stroke();
                    if (o.icon) {
                        const last = o.path[o.path.length - 1];
                        ctx.font = '30px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(o.icon, last.x, last.y);
                    }
                });

                // 3) ì§„í–‰ ì¤‘
                for (let i = 0; i < animatingPaths.length; i++) {
                    const ap = animatingPaths[i];
                    const pts = ap.path;
                    const idx = Math.min(Math.floor(ap.currentIndex), pts.length - 1);
                    ctx.strokeStyle = ap.color; ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let j = 1; j <= idx; j++) ctx.lineTo(pts[j].x, pts[j].y);
                    ctx.stroke();
                    if (ap.icon) {
                        ctx.font = '30px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(ap.icon, pts[idx].x, pts[idx].y);
                    }
                    ap.currentIndex += ANIMATION_SPEED;
                    if (ap.currentIndex >= pts.length) {
                        drawnPaths.push({ path: pts, color: ap.color, icon: ap.icon });
                        animatingPaths.splice(i, 1);
                        i--;
                    }
                }

                lastFrameTime = ts;
                if (animatingPaths.length) requestAnimationFrame(animateFrame);
                else animationRunning = false;
            }

            // í´ë¦­/í„°ì¹˜ í•¸ë“¤ëŸ¬
            function handleInteraction(evt) {
                const rect = gameCanvas.getBoundingClientRect();
                const clientX = evt.clientX ?? evt.touches[0].clientX;
                const clientY = evt.clientY ?? evt.touches[0].clientY;
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                for (const b of nameBoxes) {
                    if (clickedIndices.has(b.colIndex)) continue;
                    if (x >= b.x1 && x <= b.x2 && y >= b.y1 && y <= b.y2) {
                        evt.preventDefault();
                        clickedIndices.add(b.colIndex);
                        const { path } = getPathPoints(b.colIndex);
                        const color = pathColors[colorIndex % pathColors.length];
                        const icon  = animalIcons[b.colIndex] || '';
                        colorIndex++;
                        animatingPaths.push({ path, color, icon, currentIndex: 0 });
                        break;
                    }
                }
                if (!animationRunning) {
                    animationRunning = true;
                    requestAnimationFrame(animateFrame);
                }
            }

            // ê²Œì„ ì‹œì‘
            startGameBtn.addEventListener('click', () => {
                clearError();
                const count = +playerCountInput.value;
                if (count < 1 || count > 10) {
                    showError('ì°¸ê°€ì ìˆ˜ëŠ” 1~10 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                    return;
                }
                const names   = [...nameList.querySelectorAll('input')].map(i => i.value.trim());
                const results = [...resultList.querySelectorAll('input')].map(i => i.value.trim());
                if (names.some(v => !v) || results.some(v => !v)) {
                    showError('ì´ë¦„ê³¼ ê²°ê³¼ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }

                // í™”ë©´ ì „í™˜
                settingBoard.classList.add('hidden');
                gameBoard.classList.remove('hidden');

                // ì ê¸ˆ
                [minusBtn, plusBtn, playerCountInput, startGameBtn].forEach(el => el.disabled = true);
                resetGameBtn.disabled = false;

                // ì´ˆê¸°í™”
                clickedIndices.clear();
                drawnPaths = [];
                animatingPaths = [];
                lastFrameTime = 0;

                const widthPx = count * 90;
                initCanvas(widthPx);
                initLadder(count);
                drawStatic(names, results);

                // ë°”ë¡œ ë³µì‚¬
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(offscreen, 0, 0, canvasWidth, canvasHeight);

                gameCanvas.addEventListener('click', handleInteraction);
                gameCanvas.addEventListener('touchstart', handleInteraction, { passive: false });
            });

            // ì´ˆê¸°í™” ë²„íŠ¼
            resetGameBtn.addEventListener('click', () => location.reload());

            // ì²« ë¡œë“œ ì‹œ ì…ë ¥ë€ ìƒì„±
            updateInputs(+playerCountInput.value);
        };
    </script>
</div>
</body>
</html>
