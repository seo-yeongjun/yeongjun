<!DOCTYPE html>
<html xmlns:layout="http://www.ultraq.net.nz/web/thymeleaf/layout"
      layout:decorate="~{coffeeGame/layout}">
<head>
    <title th:text="${title} ?: 'ì‚¬ë‹¤ë¦¬íƒ€ê¸° ğŸªœ'"></title>
</head>
<body>
<div layout:fragment="content">
    <!-- ì„¤ì • ì˜ì—­ -->
    <div id="settingBoard" class="container mx-auto py-8">
        <div class="flex justify-center items-center">
            <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-md flex flex-col items-center">
                <!-- ì°¸ê°€ì ìˆ˜ ì…ë ¥ -->
                <div class="flex items-center space-x-2 mb-4">
                    <label for="playerCount" class="font-medium text-gray-700">ì°¸ê°€ì ìˆ˜</label>
                    <input
                            type="number"
                            id="playerCount"
                            class="w-16 text-center border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value="5"
                    >
                    <button
                            id="playerCountBtn"
                            class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 transition duration-200 focus:outline-none"
                    >
                        ì ìš©/ì´ˆê¸°í™”
                    </button>
                </div>

                <!-- ì´ë¦„/ê²°ê³¼ ì…ë ¥ ì˜ì—­ -->
                <div id="labelArea" class="hidden w-full">
                    <div class="flex justify-between">
                        <!-- ì´ë¦„ ë¦¬ìŠ¤íŠ¸ -->
                        <div id="nameList" class="flex flex-col items-center space-y-2 w-1/2 pr-2">
                            <!-- JSì—ì„œ ë™ì  ìƒì„± -->
                        </div>
                        <!-- ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ -->
                        <div id="resultList" class="flex flex-col items-center space-y-2 w-1/2 pl-2">
                            <!-- JSì—ì„œ ë™ì  ìƒì„± -->
                        </div>
                    </div>
                </div>

                <div class="mt-4 hidden" id="gameBtnArea">
                    <button
                            id="startGame"
                            class="bg-green-500 text-white px-4 py-1 rounded hover:bg-green-600 transition duration-200 focus:outline-none mr-2"
                    >
                        ê²Œì„ ì‹œì‘
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- ì‹¤ì œ ì‚¬ë‹¤ë¦¬ ê²Œì„ ë³´ë“œ (ê²°ê³¼ í‘œì‹œ) -->
    <div id="gameBoard" class="md:max-w-[82vw] hidden mx-auto mt-4 bg-white rounded-lg shadow-md">
        <!-- ì´ˆê¸°í™” ë²„íŠ¼ -->
        <div class="flex justify-center mb-4">
            <button
                    id="resetGame"
                    class="bg-red-500 text-white px-4 py-1 rounded hover:bg-red-600 transition duration-200 focus:outline-none"
            >
                ì´ˆê¸°í™”
            </button>
        </div>
        <div class="overflow-x-auto">
        <canvas id="gameCanvas" class="mx-auto h-[50vh] border border-gray-300"></canvas>
        </div>
    </div>
    <script>
        /***********************************************************
         * [1] ì´ˆê¸° í™”ë©´ ì œì–´ (ì´ë¦„/ê²°ê³¼ Input ìƒì„±, ì´ˆê¸°í™” ë²„íŠ¼ ë“±)
         ***********************************************************/
        window.onload = () => {
            const playerCount = document.getElementById('playerCount');
            const playerCountBtn = document.getElementById('playerCountBtn');

            const nameList = document.getElementById('nameList');
            const resultList = document.getElementById('resultList');
            const labelArea = document.getElementById('labelArea');

            const gameBtnArea = document.getElementById('gameBtnArea');
            const startGame = document.getElementById('startGame');

            const settingBoard = document.getElementById('settingBoard');
            const gameBoard = document.getElementById('gameBoard');

            const gameCanvas = document.getElementById('gameCanvas');
            const resetGame = document.getElementById('resetGame');

            // [ì ìš©/ì´ˆê¸°í™”] ë²„íŠ¼ í´ë¦­ ì‹œ, ì´ë¦„/ê²°ê³¼ Input ìƒì„±
            playerCountBtn.addEventListener('click', () => {
                labelArea.classList.remove('hidden');
                gameBtnArea.classList.remove('hidden');

                const count = parseInt(playerCount.value, 10);
                // ê¸°ì¡´ì— ë‚¨ì•„ìˆë˜ input ì œê±°
                nameList.innerHTML = '<label class="font-medium text-gray-700">í”Œë ˆì´ì–´ ì´ë¦„</label>';
                resultList.innerHTML = '<label class="font-medium text-gray-700">ê²°ê³¼</label>';

                // nameInputs
                for (let i = 0; i < count; i++) {
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = `í”Œë ˆì´ì–´${i + 1}`;
                    nameInput.className = 'w-full border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500';
                    // í´ë¦­ ì‹œ ê¸°ë³¸ê°’ ì§€ìš°ê¸°
                    nameInput.addEventListener('click', () => {
                        nameInput.value = '';
                    });
                    nameList.appendChild(nameInput);
                }

                // resultInputs
                for (let i = 0; i < count; i++) {
                    const resultInput = document.createElement('input');
                    resultInput.type = 'text';
                    resultInput.value = `O`;
                    resultInput.className = 'w-full border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500';
                    // í´ë¦­ ì‹œ ê¸°ë³¸ê°’ ì§€ìš°ê¸°
                    resultInput.addEventListener('click', () => {
                        resultInput.value = '';
                    });
                    resultList.appendChild(resultInput);
                }
            });

            // ì´ˆê¸°í™” ë²„íŠ¼
            resetGame.addEventListener('click', () => {
                window.location.reload();
            });

            // [ê²Œì„ ì‹œì‘] ë²„íŠ¼
            startGame.addEventListener('click', () => {

                const names = document.querySelectorAll('#nameList input');
                const results = document.querySelectorAll('#resultList input');
                const nameArr = [];
                const resultArr = [];

                names.forEach(name => nameArr.push(name.value));
                results.forEach(result => resultArr.push(result.value));

                // ì„¤ì • ì˜ì—­ ê°ì¶”ê³ , Canvas ì˜ì—­ í‘œì‹œ
                settingBoard.classList.add('hidden');
                gameBoard.classList.remove('hidden');

                const count = parseInt(playerCount.value, 10);
                gameCanvas.style.width = (count * 90) + 'px';

                // ì‚¬ë‹¤ë¦¬ ê²Œì„ ì‹¤í–‰
                initCanvas();             // <= ì—¬ê¸°ì„œ ì‹¤ì œë¡œ canvasWidth / canvasHeight í™•ì •
                runLadderGame(nameArr, resultArr);
            });
        };


        /***********************************************************
         * [2] ì‚¬ë‹¤ë¦¬ ë¡œì§ + Canvas
         ***********************************************************/
        let ctx;
        let canvasWidth, canvasHeight;


        // ì‚¬ë‹¤ë¦¬ ë§µ(ê°€ë¡œì¤„) ì •ë³´: ladderMap[row][col] => boolean
        let ladderMap = [];
        // ì„¸ë¡œì¤„ ê°œìˆ˜
        let verticalCount = 0;
        // ê°€ë¡œì¤„(í–‰) ê°œìˆ˜ (ì›í•˜ëŠ” ë§Œí¼ ì¡°ì •)
        let rowCount = 15;

        const topMargin = 50;    // ì´ë¦„ í‘œì‹œ ì˜ì—­ë³´ë‹¤ ì‚´ì§ ì—¬ìœ  ìˆê²Œ
        const bottomMargin = 50; // ê²°ê³¼ í‘œì‹œ ì˜ì—­ë³´ë‹¤ ì‚´ì§ ì—¬ìœ  ìˆê²Œ

        // ë¼ì¸ ìƒ‰ìƒ/ë‘ê»˜
        const lineColor = '#999';
        const lineWidth = 2;

        // ì´ë¯¸ ê·¸ë ¤ì§„ ê²½ë¡œ(ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚œ í›„ì—ë„ ìœ ì§€) ëª©ë¡
        // [{ points: [ {x, y}, ... ], color: '#f00' }]
        let drawnPaths = [];

        // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œë“¤
        // [{ points: [...], color: '', currentIndex: 0, finalIndex: (ë„ì°©col) }]
        let animatingPaths = [];

        // ì´ë¦„/ê²°ê³¼ë¥¼ í´ë¦­í•˜ê¸° ìœ„í•œ ì˜ì—­ ì €ì¥
        // ì´ë¦„: [{ x1, y1, x2, y2, colIndex }]
        let nameBoxes = [];

        // ë§¤ë²ˆ ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ ê²½ë¡œë¥¼ ê·¸ë¦¬ê¸° ìœ„í•´, ì„ì˜ ìƒ‰ìƒ ëª©ë¡ or randomColor
        const pathColors = ['red', 'blue', 'green', 'orange', 'purple', 'teal', 'hotpink', 'brown'];
        let colorIndex = 0;

        /**
         * ì‚¬ë‹¤ë¦¬(ê°€ë¡œì¤„) ì •ë³´ ì´ˆê¸°í™”
         */
        function initLadder(count) {
            verticalCount = count;
            ladderMap = [];
            for (let r = 0; r < rowCount; r++) {
                const row = new Array(verticalCount - 1).fill(false);
                for (let c = 0; c < verticalCount - 1; c++) {
                    // ì´ë¯¸ ì´ì „ colì´ trueë©´, ì´ë²ˆ colì€ ë¬´ì¡°ê±´ falseë¡œ (ì¤‘ë³µ ë°©ì§€)
                    if (c > 0 && row[c - 1] === true) {
                        row[c] = false;
                        continue;
                    }

                    // ëœë¤í•˜ê²Œ true/false
                    if (Math.random() < 0.4) {
                        row[c] = true;
                    } else {
                        row[c] = false;
                    }
                }
                ladderMap.push(row);
            }
        }

        /**
         * Canvas í¬ê¸° ë° ë°°ê²½ ì´ˆê¸°í™”
         */
        function initCanvas() {
            ctx = gameCanvas.getContext('2d');

            // styleë¡œ ì§€ì •ëœ widthë¥¼ ì‹¤ì œ ìˆ«ìë¡œ ê°€ì ¸ì˜¤ê±°ë‚˜,
            // ë˜ëŠ” offsetWidth ë“±ì„ í•œ ë²ˆë§Œ ì“°ë„ë¡
            canvasWidth = parseInt(gameCanvas.style.width, 10);
            // ë†’ì´ëŠ” Tailwind h-[50vh] ë“±ìœ¼ë¡œ ì¡ê³  ìˆë‹¤ë©´ offsetHeight ì‚¬ìš©
            canvasHeight = gameCanvas.offsetHeight;

            gameCanvas.width = canvasWidth;
            gameCanvas.height = canvasHeight;

            // ì´ˆê¸° ë°°ê²½
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }


        /**
         * ì‚¬ë‹¤ë¦¬(ì„¸ë¡œì¤„/ê°€ë¡œì¤„) ê·¸ë¦¬ê¸°
         */
        function drawLadder() {
            const usableHeight = canvasHeight - topMargin - bottomMargin;
            // rowCount+1 ë¡œ ë‚˜ëˆˆ ë†’ì´ ê°„ê²©
            const gapY = usableHeight / (rowCount + 1);

            const gapX = canvasWidth / (verticalCount + 1);

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;

            for (let i = 1; i <= verticalCount; i++) {
                const x = gapX * i;
                ctx.beginPath();
                // ì„¸ë¡œì¤„ì€ topMarginì—ì„œ ì‹œì‘ â†’ canvasHeight - bottomMarginì—ì„œ ë
                ctx.moveTo(x, topMargin);
                ctx.lineTo(x, canvasHeight - bottomMargin);
                ctx.stroke();
            }

            // [B] ê°€ë¡œì¤„
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < verticalCount - 1; c++) {
                    if (ladderMap[r][c]) {
                        const x1 = gapX * (c + 1);
                        const x2 = gapX * (c + 2);

                        // row rì— í•´ë‹¹í•˜ëŠ” yì¢Œí‘œëŠ” topMargin + gapY*(r+1)
                        const y = topMargin + gapY * (r + 1);

                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                    }
                }
            }
        }

        /**
         * í…ìŠ¤íŠ¸ë¥¼ ê·¸ë¦´ ë•Œ, maxWidthë³´ë‹¤ ê¸¸ë©´ í°íŠ¸ë¥¼ 1ì”© ê°ì†Œì‹œí‚¤ë©° ë§ì¶°ì£¼ëŠ” í•¨ìˆ˜
         * - ë°˜í™˜ê°’: ìµœì¢… í™•ì •ëœ í°íŠ¸ í¬ê¸°(px)
         */
        function fitTextToWidth(ctx, text, maxWidth, initialFontSize, minFontSize) {
            let fontSize = initialFontSize;

            // ìµœì´ˆ í°íŠ¸ ì§€ì •
            ctx.font = `${fontSize}px sans-serif`;
            let textWidth = ctx.measureText(text).width;

            // textWidthê°€ maxWidthë¥¼ ì´ˆê³¼í•˜ë©´ í°íŠ¸ë¥¼ ì¤„ì—¬ë‚˜ê°
            while (textWidth > maxWidth && fontSize > minFontSize) {
                fontSize--;
                ctx.font = `${fontSize}px sans-serif`;
                textWidth = ctx.measureText(text).width;
            }

            return fontSize;
        }

        /**
         * Canvas ìƒë‹¨ì— ì´ë¦„ë“¤ ê·¸ë¦¬ê¸° + í´ë¦­ ì˜ì—­ ì €ì¥
         */
        function drawNames(nameArr) {
            const gapX = canvasWidth / (verticalCount + 1);

            // ê° ë²„íŠ¼ì˜ ìµœëŒ€ í­ì€ gapXë¥¼ ê±°ì˜ ë‹¤ ì“°ê²Œ í•  ìˆ˜ë„, ì¼ë¶€ë§Œ ì“°ê²Œ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
            // ì˜ˆ: "ë²„íŠ¼ ìì²´ëŠ” gapX * 0.8" ì •ë„ë¡œ í•˜ì—¬ ì•½ê°„ ì—¬ë°± ë‚¨ê¸°ê¸°
            const maxButtonWidthRatio = 0.8;
            // ì´ˆê¸°/ìµœì†Œ í°íŠ¸ ì‚¬ì´ì¦ˆ ì§€ì • (ì›í•˜ëŠ” ê°’ìœ¼ë¡œ ì¡°ì ˆ ê°€ëŠ¥)
            const initialFontSize = 16;
            const minFontSize = 8;

            // ë²„íŠ¼ì˜ ìœ„ì•„ë˜/ì¢Œìš° ì—¬ë°±
            const paddingX = 10;
            const paddingY = 5;

            // nameBoxesëŠ” ì „ì—­ ë°°ì—´(í´ë¦­ ì˜ì—­ìš©)ì´ë¼ ê°€ì •
            nameBoxes = [];

            for (let i = 0; i < nameArr.length; i++) {
                const text = nameArr[i];

                // ìš°ì„  ë²„íŠ¼ ì „ì²´ í­ì„ êµ¬í•©ë‹ˆë‹¤.
                const buttonMaxWidth = gapX * maxButtonWidthRatio;

                // 1) í°íŠ¸ í¬ê¸°ë¥¼ ê³„ì‚° (ë„ˆë¹„ì— ë§ì¶° ì¤„ì´ê¸°)
                //    measureText í•˜ê¸° ìœ„í•´ ctx.font ë¥¼ ì„¤ì •í•´ì•¼ í•˜ë¯€ë¡œ,
                //    fitTextToWidth í•¨ìˆ˜ì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ê³„ì† fontë¥¼ ë°”ê¿‰ë‹ˆë‹¤.
                let fontSize = fitTextToWidth(ctx, text, buttonMaxWidth - paddingX * 2, initialFontSize, minFontSize);

                // fitTextToWidth ëë‚œ ë’¤ ìµœì¢… í°íŠ¸ í¬ê¸°ë¡œ ë‹¤ì‹œ ì„¤ì •í•´ì•¼ í•¨
                ctx.font = `${fontSize}px sans-serif`;
                let textWidth = ctx.measureText(text).width;
                let textHeight = fontSize; // ëŒ€ëµ í°íŠ¸ í¬ê¸°ë¥¼ ë†’ì´ë¡œ ì¡ìŠµë‹ˆë‹¤.

                // 2) ë²„íŠ¼ì˜ ì‹¤ì œ í­/ë†’ì´
                //    = ê¸€ì í­ + ì¢Œìš° íŒ¨ë”©, ê¸€ì ë†’ì´ + ìƒí•˜ íŒ¨ë”©
                const buttonWidth = textWidth + paddingX * 2;
                const buttonHeight = textHeight + paddingY * 2;

                // 3) ë²„íŠ¼ì˜ ì¢Œí‘œ (xCenterëŠ” í•´ë‹¹ colì˜ ì¤‘ì•™)
                const xCenter = gapX * (i + 1);

                // ì—¬ê¸°ì„œëŠ” ë²„íŠ¼ ìƒë‹¨ì„ topMarginë³´ë‹¤ ì¡°ê¸ˆ ìœ„(ë˜ëŠ” ì•½ê°„ ì•„ë˜) ì¡ê³  ì‹¶ë‹¤ë©´
                // -10 ì •ë„ë§Œ ë¹¼ë„ ë˜ê³ , ì›í•˜ëŠ” ìœ„ì¹˜ì— ë°°ì¹˜
                const buttonX = xCenter - buttonWidth / 2;
                const buttonY = topMargin - (buttonHeight + 10);

                // 4) ë²„íŠ¼ ë°°ê²½ ê·¸ë¦¬ê¸°
                ctx.fillStyle = '#EEEEEE';        // ë²„íŠ¼ ë°°ê²½ìƒ‰
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // ì›í•œë‹¤ë©´ í…Œë‘ë¦¬ë„ ê°€ëŠ¥
                ctx.strokeStyle = '#999999';
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // 5) í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
                ctx.fillStyle = '#333333';
                // í…ìŠ¤íŠ¸ ì‹œì‘ì : ë²„íŠ¼ ì™¼ìª½ + paddingX, ë²„íŠ¼ ìœ„ + paddingY + (ì•½ê°„ ì•„ë˜)
                const textStartX = buttonX + paddingX;
                const textStartY = buttonY + paddingY + textHeight * 0.8;
                // (canvasì—ì„œëŠ” í…ìŠ¤íŠ¸ê°€ baseline ê¸°ì¤€ì´ë¯€ë¡œ, ì•½ê°„ 0.8 ~ 0.9 ê³±í•´ì„œ ì•„ë˜ë¡œ ë§ì¶¤)

                ctx.fillText(text, textStartX, textStartY);

                // 6) í´ë¦­ ì˜ì—­ ì €ì¥
                // ì‹¤ì œë¡œëŠ” ë²„íŠ¼ ì „ì²´ê°€ í´ë¦­ ì˜ì—­ì´ë¯€ë¡œ
                nameBoxes.push({
                    x1: buttonX,
                    y1: buttonY,
                    x2: buttonX + buttonWidth,
                    y2: buttonY + buttonHeight,
                    colIndex: i
                });
            }
        }


        /**
         * Canvas í•˜ë‹¨ì— ê²°ê³¼ë“¤ í‘œì‹œ (ë‹¨ìˆœ í…ìŠ¤íŠ¸)
         * - ê°€ë¡œì¤„(ì„¸ë¡œì¤„)ê³¼ ë™ì¼í•œ x ìœ„ì¹˜ì— í‘œì‹œ
         */
        function drawResults(resultArr) {
            const gapX = canvasWidth / (verticalCount + 1);

            // ì´ˆê¸°/ìµœì†Œ í°íŠ¸
            const initialFontSize = 16;
            const minFontSize = 8;

            for (let i = 0; i < resultArr.length; i++) {
                const text = resultArr[i];

                // ìµœëŒ€ í­ ì„¤ì • (gapX * 0.8 ì •ë„)
                const maxTextWidth = gapX * 0.8;

                // í°íŠ¸ í¬ê¸° ë§ì¶”ê¸°
                let fontSize = fitTextToWidth(ctx, text, maxTextWidth, initialFontSize, minFontSize);

                // ìµœì¢… í°íŠ¸ ì„¤ì •
                ctx.font = `${fontSize}px sans-serif`;
                ctx.fillStyle = '#333';

                // ì¸¡ì •
                let textWidth = ctx.measureText(text).width;
                let textHeight = fontSize;

                // í•˜ë‹¨ì— ë°°ì¹˜ (ì¤‘ì•™ ì •ë ¬)
                const xCenter = gapX * (i + 1);
                const textX = xCenter - (textWidth / 2);
                // bottomMargin ì•„ë˜ìª½ì— ê¸€ìë¥¼ í‘œì‹œí•˜ë©´ ì§¤ë¦¬ë¯€ë¡œ, ì•½ê°„ ìœ„ë¡œ ì˜¬ë¦¼
                const textY = canvasHeight - bottomMargin + textHeight;

                // ê·¸ë¦¬ê¸°
                ctx.fillText(text, textX, textY);
            }
        }


        /**
         * colIndex(0-based) ì— í•´ë‹¹í•˜ëŠ” ê²½ë¡œì˜ ëª¨ë“  ì¢Œí‘œë¥¼ ê³„ì‚°í•´ì„œ ë°˜í™˜
         * - [ { x, y }, { x, y }, ... ] í˜•íƒœ
         * - ë§¨ ìœ„( y=0 )ë¶€í„° â†’ ê°€ë¡œì¤„/ì„¸ë¡œì¤„ â†’ ë§¨ ì•„ë˜( y=canvasHeight )
         */
        function getPathPoints(colIndex) {
            const points = [];
            const usableHeight = canvasHeight - topMargin - bottomMargin;
            const gapY = usableHeight / (rowCount + 1);
            const gapX = canvasWidth / (verticalCount + 1);

            // í˜„ì¬ ì„¸ë¡œì¤„ colIndex
            let c = colIndex;

            // ì‹œì‘ X/Y
            let currentX = gapX * (c + 1);
            let currentY = topMargin;  // ê¼­ëŒ€ê¸°ê°€ ì•„ë‹ˆë¼ topMargin ì§€ì ì—ì„œ ì‹œì‘

            // ì²« ì 
            points.push({x: currentX, y: currentY});

            // rowCountê°œì˜ 'í–‰'ì„ ë”°ë¼ ë‚´ë ¤ê°€ë©° ì¢Œìš° ì´ë™
            for (let r = 0; r < rowCount; r++) {
                const nextY = topMargin + gapY * (r + 1);
                // 1) ì„¸ë¡œë¡œ ë‚´ë ¤ê°€ê¸°
                points.push({x: currentX, y: nextY});

                // 2) ê°€ë¡œì¤„ ì²´í¬
                // ì™¼ìª½
                if (c > 0 && ladderMap[r][c - 1]) {
                    // ì™¼ìª½ ì´ë™
                    const leftX = gapX * c;
                    points.push({x: leftX, y: nextY});
                    c--;
                    currentX = leftX;
                }
                // ì˜¤ë¥¸ìª½
                else if (c < verticalCount - 1 && ladderMap[r][c]) {
                    // ì˜¤ë¥¸ìª½ ì´ë™
                    const rightX = gapX * (c + 2);
                    points.push({x: rightX, y: nextY});
                    c++;
                    currentX = rightX;
                }
            }

            // ë§¨ ì•„ë˜ê¹Œì§€
            points.push({x: currentX, y: canvasHeight - bottomMargin});

            // ìµœì¢… ë„ì°© colIndex ë°˜í™˜ë„ í•´ì•¼ í•˜ë¯€ë¡œ, c ê°’ë„ return
            return {path: points, finalCol: c};
        }

        /**
         * pathPointsë¥¼ "ì• ë‹ˆë©”ì´ì…˜"ìœ¼ë¡œ ê·¸ë¦¬ê¸°
         * - setInterval or requestAnimationFrame
         * - ë§¤ í”„ë ˆì„ë§ˆë‹¤ nextPointë¡œ ì„ ì„ ì—°ì¥
         */
        function animatePath(pathPoints, color, finalColIndex, name, result) {
            // animatingPathsì— ë“±ë¡
            animatingPaths.push({
                points: pathPoints,
                color,
                currentIndex: 0,
                finalCol: finalColIndex,
                name,
                result
            });

            // í˜¹ì‹œ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ê°€ ëŒê³  ìˆì§€ ì•Šë‹¤ë©´, ì‹œì‘
            if (!animationRunning) {
                animationRunning = true;
                requestAnimationFrame(drawAnimationFrame);
            }
        }

        // í˜„ì¬ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ë™ì‘ ì¤‘ì¸ì§€ í™•ì¸
        let animationRunning = false;

        /**
         * ëª¨ë“  ê²½ë¡œ(ì´ë¯¸ ê·¸ë ¤ì§„ + ì• ë‹ˆë©”ì´ì…˜ ì¤‘)ë¥¼ ê·¸ë¦¬ê¸° ìœ„í•´
         * ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì‹¤í–‰ë  í•¨ìˆ˜
         */
        // [ìˆ˜ì •] ë” ì´ìƒ ë§¤ í”„ë ˆì„ë§ˆë‹¤ initCanvas() í˜¸ì¶œí•˜ì§€ ë§ê³ 
//       ë§¨ ìœ„ì— ìˆë˜ initCanvas()ì™€ ë°°ê²½ ì±„ìš°ëŠ” ë¶€ë¶„ì€ ì œì™¸.
        function drawAnimationFrame() {
            // 1) ë°°ê²½ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // 2) Ladder, Names, Results ë‹¤ì‹œ ê·¸ë¦¼
            drawLadder();
            drawNames(currentNameArr);
            drawResults(currentResultArr);

            // 3) ì´ë¯¸ ê·¸ë ¤ì§„ ê²½ë¡œ(drawnPaths) ê·¸ë¦¬ê¸°
            drawnPaths.forEach(pathObj => {
                drawFullPath(pathObj.points, pathObj.color);
            });

            // 4) ì§„í–‰ ì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ ê²½ë¡œ(animatingPaths) ê·¸ë¦¬ê¸°
            for (let i = 0; i < animatingPaths.length; i++) {
                const ap = animatingPaths[i];
                drawPartialPath(ap.points, ap.color, ap.currentIndex);
                ap.currentIndex += 0.2;

                // ê²½ë¡œ ëê¹Œì§€ ê·¸ë ¸ìœ¼ë©´, drawnPathsë¡œ ì˜®ê¸°ê³  ì œê±°
                if (ap.currentIndex >= ap.points.length) {
                    drawnPaths.push({points: ap.points, color: ap.color});
                    animatingPaths.splice(i, 1);
                    i--;
                }
            }

            // 5) ì—¬ì „íˆ ì• ë‹ˆë©”ì´ì…˜ ê²½ë¡œê°€ ë‚¨ì•„ìˆìœ¼ë©´ ê³„ì† ë£¨í”„
            if (animatingPaths.length > 0) {
                requestAnimationFrame(drawAnimationFrame);
            } else {
                animationRunning = false;
            }
        }

        /**
         * ì´ë¯¸ ì™„ë£Œëœ ê²½ë¡œ(ì „ì²´)ë¥¼ í•œ ë²ˆì— ê·¸ë¦¬ê¸°
         */
        function drawFullPath(points, color) {
            if (!points || points.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        /**
         * ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œë¥¼ í˜„ì¬ ì¸ë±ìŠ¤ê¹Œì§€ ë¶€ë¶„ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
         */
        function drawPartialPath(points, color, currentIndex) {
            if (!points || points.length < 2) return;
            if (currentIndex < 1) currentIndex = 1; // ìµœì†Œ 1ê°œ ì„ ë¶„ì€ ê·¸ë ¤ì•¼ í•¨
            if (currentIndex > points.length) currentIndex = points.length;

            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < currentIndex; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        // í˜„ì¬ ê·¸ë ¤ì§ˆ ì´ë¦„/ê²°ê³¼ ë°°ì—´ì„ ì €ì¥í•´ë‘ê³ , ë§¤ í”„ë ˆì„ë§ˆë‹¤ ê·¸ë¦¬ê¸° ìœ„í•´ ì „ì—­ì— ë³´ê´€
        let currentNameArr = [];
        let currentResultArr = [];

        /**
         * ìµœì¢… ì‹¤í–‰ í•¨ìˆ˜
         */
        function runLadderGame(nameArr, resultArr) {
            currentNameArr = nameArr;
            currentResultArr = resultArr;

            // 1) ì‚¬ë‹¤ë¦¬ ì •ë³´ ì´ˆê¸°í™”
            initLadder(nameArr.length);

            // 2) Canvas ì´ˆê¸°í™”
            initCanvas();

            // 3) ì‚¬ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
            drawLadder();

            // 4) ì´ë¦„, ê²°ê³¼ í‘œì‹œ
            drawNames(nameArr);
            drawResults(resultArr);

            // 5) í´ë¦­ ì´ë²¤íŠ¸(ì´ë¦„ í´ë¦­) ë“±ë¡
            const gameCanvas = document.getElementById('gameCanvas');
            gameCanvas.addEventListener('click', (event) => {
                const rect = gameCanvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;

                // nameBoxes í™•ì¸
                for (let box of nameBoxes) {
                    if (
                        clickX >= box.x1 && clickX <= box.x2 &&
                        clickY >= box.y1 && clickY <= box.y2
                    ) {
                        // colIndex = box.colIndex
                        // 1) ê²½ë¡œ ê³„ì‚°
                        const {path, finalCol} = getPathPoints(box.colIndex);

                        // 2) ìƒˆ ê²½ë¡œì— ëŒ€í•´ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                        //    - ìƒ‰ìƒì€ pathColorsì—ì„œ ìˆœí™˜ ì‚¬ìš© or ëœë¤
                        const color = pathColors[colorIndex % pathColors.length];
                        colorIndex++;

                        animatePath(path, color, finalCol, nameArr[box.colIndex], resultArr);

                        // ë‹¤ë¥¸ ì´ë¦„ ë°•ìŠ¤ë„ í™•ì¸ ì•ˆ í•˜ë„ë¡ ì¢…ë£Œ
                        break;
                    }
                }
            });
        }
    </script>
</div>
</body>
</html>