<!DOCTYPE html>
<html xmlns:layout="http://www.ultraq.net.nz/web/thymeleaf/layout"
      layout:decorate="~{coffeeGame/layout}">
<head>
    <title th:text="${title} ?: 'ì‚¬ë‹¤ë¦¬íƒ€ê¸° ğŸªœ'"></title>
</head>
<body>
<div layout:fragment="content">
    <!-- ì„¤ì • ì˜ì—­ -->
    <div id="settingBoard" class="container mx-auto py-8">
        <div class="flex justify-center items-center">
            <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-md flex flex-col items-center">
                <!-- ì°¸ê°€ì ìˆ˜ ì…ë ¥ -->
                <div class="flex items-center space-x-2 mb-4">
                    <label for="playerCount" class="font-medium text-gray-700">ì°¸ê°€ì ìˆ˜</label>
                    <input
                            type="number"
                            id="playerCount"
                            class="w-16 text-center border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value="5"
                    >
                    <button
                            id="playerCountBtn"
                            class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 transition duration-200 focus:outline-none"
                    >
                        ì ìš©/ì´ˆê¸°í™”
                    </button>
                </div>

                <!-- ì´ë¦„/ê²°ê³¼ ì…ë ¥ ì˜ì—­ -->
                <div id="labelArea" class="hidden w-full">
                    <div class="flex justify-between">
                        <!-- ì´ë¦„ ë¦¬ìŠ¤íŠ¸ -->
                        <div id="nameList" class="flex flex-col items-center space-y-2 w-1/2 pr-2">
                            <!-- JSì—ì„œ ë™ì  ìƒì„± -->
                        </div>
                        <!-- ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ -->
                        <div id="resultList" class="flex flex-col items-center space-y-2 w-1/2 pl-2">
                            <!-- JSì—ì„œ ë™ì  ìƒì„± -->
                        </div>
                    </div>
                </div>

                <div class="mt-4 hidden" id="gameBtnArea">
                    <button
                            id="startGame"
                            class="bg-green-500 text-white px-4 py-1 rounded hover:bg-green-600 transition duration-200 focus:outline-none mr-2"
                    >
                        ê²Œì„ ì‹œì‘
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- ì‹¤ì œ ì‚¬ë‹¤ë¦¬ ê²Œì„ ë³´ë“œ (ê²°ê³¼ í‘œì‹œ) -->
    <div id="gameBoard" class="hidden container mx-auto mt-4 bg-white rounded-lg shadow-md">
        <!-- ì´ˆê¸°í™” ë²„íŠ¼ -->
        <div class="flex justify-end mb-4">
            <button
                    id="resetGame"
                    class="bg-red-500 text-white px-4 py-1 rounded hover:bg-red-600 transition duration-200 focus:outline-none"
            >
                ì´ˆê¸°í™”
            </button>
        </div>
        <canvas id="gameCanvas" class="w-full h-[50vh] border border-gray-300"></canvas>
    </div>
    <script>
        /***********************************************************
         * [1] ì´ˆê¸° í™”ë©´ ì œì–´ (ì´ë¦„/ê²°ê³¼ Input ìƒì„±, ì´ˆê¸°í™” ë²„íŠ¼ ë“±)
         ***********************************************************/
        window.onload = () => {
            const playerCount = document.getElementById('playerCount');
            const playerCountBtn = document.getElementById('playerCountBtn');

            const nameList = document.getElementById('nameList');
            const resultList = document.getElementById('resultList');
            const labelArea = document.getElementById('labelArea');

            const gameBtnArea = document.getElementById('gameBtnArea');
            const startGame = document.getElementById('startGame');

            const settingBoard = document.getElementById('settingBoard');
            const gameBoard = document.getElementById('gameBoard');

            const gameCanvas = document.getElementById('gameCanvas');
            const resetGame = document.getElementById('resetGame');

            // [ì ìš©/ì´ˆê¸°í™”] ë²„íŠ¼ í´ë¦­ ì‹œ, ì´ë¦„/ê²°ê³¼ Input ìƒì„±
            playerCountBtn.addEventListener('click', () => {
                labelArea.classList.remove('hidden');
                gameBtnArea.classList.remove('hidden');

                const count = parseInt(playerCount.value, 10);
                // ê¸°ì¡´ì— ë‚¨ì•„ìˆë˜ input ì œê±°
                nameList.innerHTML = '<label class="font-medium text-gray-700">í”Œë ˆì´ì–´ ì´ë¦„</label>';
                resultList.innerHTML = '<label class="font-medium text-gray-700">ê²°ê³¼</label>';

                // nameInputs
                for (let i = 0; i < count; i++) {
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = `í”Œë ˆì´ì–´${i + 1}`;
                    nameInput.className = 'w-full border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500';
                    // í´ë¦­ ì‹œ ê¸°ë³¸ê°’ ì§€ìš°ê¸°
                    nameInput.addEventListener('click', () => {
                        nameInput.value = '';
                    });
                    nameList.appendChild(nameInput);
                }

                // resultInputs
                for (let i = 0; i < count; i++) {
                    const resultInput = document.createElement('input');
                    resultInput.type = 'text';
                    resultInput.value = `O`;
                    resultInput.className = 'w-full border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500';
                    // í´ë¦­ ì‹œ ê¸°ë³¸ê°’ ì§€ìš°ê¸°
                    resultInput.addEventListener('click', () => {
                        resultInput.value = '';
                    });
                    resultList.appendChild(resultInput);
                }
            });

            // ì´ˆê¸°í™” ë²„íŠ¼
            resetGame.addEventListener('click', () => {
                settingBoard.classList.remove('hidden');
                gameBoard.classList.add('hidden');

                // settingBoard ì´ˆê¸°í™”
                playerCount.value = 5;
                labelArea.classList.add('hidden');
                gameBtnArea.classList.add('hidden');
                nameList.innerHTML = '';
                resultList.innerHTML = '';

                // gameBoard ì´ˆê¸°í™” (canvas ë“±)
                drawnPaths = [];
                animatingPaths = [];
            });

            // [ê²Œì„ ì‹œì‘] ë²„íŠ¼
            startGame.addEventListener('click', () => {
                const names = document.querySelectorAll('#nameList input');
                const results = document.querySelectorAll('#resultList input');
                const nameArr = [];
                const resultArr = [];

                names.forEach(name => nameArr.push(name.value));
                results.forEach(result => resultArr.push(result.value));

                // ì„¤ì • ì˜ì—­ ê°ì¶”ê³ , Canvas ì˜ì—­ í‘œì‹œ
                settingBoard.classList.add('hidden');
                gameBoard.classList.remove('hidden');

                // ì‚¬ë‹¤ë¦¬ ê²Œì„ ì‹¤í–‰
                runLadderGame(nameArr, resultArr);
            });
        };


        /***********************************************************
         * [2] ì‚¬ë‹¤ë¦¬ ë¡œì§ + Canvas
         ***********************************************************/
        let ctx;
        let canvasWidth, canvasHeight;


        // ì‚¬ë‹¤ë¦¬ ë§µ(ê°€ë¡œì¤„) ì •ë³´: ladderMap[row][col] => boolean
        let ladderMap = [];
        // ì„¸ë¡œì¤„ ê°œìˆ˜
        let verticalCount = 0;
        // ê°€ë¡œì¤„(í–‰) ê°œìˆ˜ (ì›í•˜ëŠ” ë§Œí¼ ì¡°ì •)
        let rowCount = 15;

        const topMargin = 50;    // ì´ë¦„ í‘œì‹œ ì˜ì—­ë³´ë‹¤ ì‚´ì§ ì—¬ìœ  ìˆê²Œ
        const bottomMargin = 50; // ê²°ê³¼ í‘œì‹œ ì˜ì—­ë³´ë‹¤ ì‚´ì§ ì—¬ìœ  ìˆê²Œ

        // ë¼ì¸ ìƒ‰ìƒ/ë‘ê»˜
        const lineColor = '#999';
        const lineWidth = 2;

        // ì´ë¯¸ ê·¸ë ¤ì§„ ê²½ë¡œ(ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚œ í›„ì—ë„ ìœ ì§€) ëª©ë¡
        // [{ points: [ {x, y}, ... ], color: '#f00' }]
        let drawnPaths = [];

        // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œë“¤
        // [{ points: [...], color: '', currentIndex: 0, finalIndex: (ë„ì°©col) }]
        let animatingPaths = [];

        // ì´ë¦„/ê²°ê³¼ë¥¼ í´ë¦­í•˜ê¸° ìœ„í•œ ì˜ì—­ ì €ì¥
        // ì´ë¦„: [{ x1, y1, x2, y2, colIndex }]
        let nameBoxes = [];

        // ë§¤ë²ˆ ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ ê²½ë¡œë¥¼ ê·¸ë¦¬ê¸° ìœ„í•´, ì„ì˜ ìƒ‰ìƒ ëª©ë¡ or randomColor
        const pathColors = ['red', 'blue', 'green', 'orange', 'purple', 'teal', 'hotpink', 'brown'];
        let colorIndex = 0;

        /**
         * ì‚¬ë‹¤ë¦¬(ê°€ë¡œì¤„) ì •ë³´ ì´ˆê¸°í™”
         */
        function initLadder(count) {
            verticalCount = count;
            ladderMap = [];
            for (let r = 0; r < rowCount; r++) {
                const row = new Array(verticalCount - 1).fill(false);
                for (let c = 0; c < verticalCount - 1; c++) {
                    // ì´ë¯¸ ì´ì „ colì´ trueë©´, ì´ë²ˆ colì€ ë¬´ì¡°ê±´ falseë¡œ (ì¤‘ë³µ ë°©ì§€)
                    if (c > 0 && row[c - 1] === true) {
                        row[c] = false;
                        continue;
                    }

                    // ëœë¤í•˜ê²Œ true/false
                    if (Math.random() < 0.4) {
                        row[c] = true;
                    } else {
                        row[c] = false;
                    }
                }
                ladderMap.push(row);
            }
        }

        /**
         * Canvas í¬ê¸° ë° ë°°ê²½ ì´ˆê¸°í™”
         */
        function initCanvas() {
            const gameCanvas = document.getElementById('gameCanvas');

            ctx = gameCanvas.getContext('2d');

            canvasWidth = gameCanvas.offsetWidth;
            canvasHeight = gameCanvas.offsetHeight;

            // ì‹¤ì œ í”½ì…€ í¬ê¸° ì§€ì •
            gameCanvas.width = canvasWidth;
            gameCanvas.height = canvasHeight;

            // ë°°ê²½ ì§€ìš°ê¸°
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // í´ë¦­ ì˜ì—­ ë°°ì—´/ê²½ë¡œë“¤ ì´ˆê¸°í™” (ë‹¨, ì´ë¯¸ ê·¸ë ¤ì§„ ê²½ë¡œëŠ” ìœ ì§€í•´ì•¼ í•˜ë¯€ë¡œ ë¹„ìš°ì§€ ì•ŠìŒ)ã…‹
            nameBoxes = [];
        }

        /**
         * ì‚¬ë‹¤ë¦¬(ì„¸ë¡œì¤„/ê°€ë¡œì¤„) ê·¸ë¦¬ê¸°
         */
        function drawLadder() {
            const usableHeight = canvasHeight - topMargin - bottomMargin;
            // rowCount+1 ë¡œ ë‚˜ëˆˆ ë†’ì´ ê°„ê²©
            const gapY = usableHeight / (rowCount + 1);

            const gapX = canvasWidth / (verticalCount + 1);

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;

            for (let i = 1; i <= verticalCount; i++) {
                const x = gapX * i;
                ctx.beginPath();
                // ì„¸ë¡œì¤„ì€ topMarginì—ì„œ ì‹œì‘ â†’ canvasHeight - bottomMarginì—ì„œ ë
                ctx.moveTo(x, topMargin);
                ctx.lineTo(x, canvasHeight - bottomMargin);
                ctx.stroke();
            }

            // [B] ê°€ë¡œì¤„
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < verticalCount - 1; c++) {
                    if (ladderMap[r][c]) {
                        const x1 = gapX * (c + 1);
                        const x2 = gapX * (c + 2);

                        // row rì— í•´ë‹¹í•˜ëŠ” yì¢Œí‘œëŠ” topMargin + gapY*(r+1)
                        const y = topMargin + gapY * (r + 1);

                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                    }
                }
            }
        }

        /**
         * Canvas ìƒë‹¨ì— ì´ë¦„ë“¤ ê·¸ë¦¬ê¸° + í´ë¦­ ì˜ì—­ ì €ì¥
         */
        function drawNames(nameArr) {
            const gapX = canvasWidth / (verticalCount + 1);
            ctx.font = '16px sans-serif';
            ctx.fillStyle = '#000';

            for (let i = 0; i < nameArr.length; i++) {
                const xCenter = gapX * (i + 1);
                const text = nameArr[i];

                // í…ìŠ¤íŠ¸ ë„ˆë¹„ ì¸¡ì •
                const textWidth = ctx.measureText(text).width;
                // topMarginë³´ë‹¤ ì‚´ì§ ìœ„ìª½ì— í‘œì‹œ â†’ (topMargin - 10) ì •ë„?
                const textX = xCenter - (textWidth / 2);
                const textY = topMargin - 10;

                ctx.fillText(text, textX, textY);

                // í´ë¦­ ì˜ì—­ ì €ì¥(ì¡°ê¸ˆ ì—¬ìœ ë¡­ê²Œ ë†’ì´ 20px ê°€ì •)
                nameBoxes.push({
                    x1: textX,
                    y1: textY - 15,
                    x2: textX + textWidth,
                    y2: textY + 5,
                    colIndex: i
                });
            }
        }

        /**
         * Canvas í•˜ë‹¨ì— ê²°ê³¼ë“¤ í‘œì‹œ (ë‹¨ìˆœ í…ìŠ¤íŠ¸)
         * - ê°€ë¡œì¤„(ì„¸ë¡œì¤„)ê³¼ ë™ì¼í•œ x ìœ„ì¹˜ì— í‘œì‹œ
         */
        function drawResults(resultArr) {
            const gapX = canvasWidth / (verticalCount + 1);
            ctx.font = '16px sans-serif';
            ctx.fillStyle = '#333';

            for (let i = 0; i < resultArr.length; i++) {
                const xCenter = gapX * (i + 1);
                const text = resultArr[i];

                const textWidth = ctx.measureText(text).width;
                const textX = xCenter - (textWidth / 2);
                const textY = canvasHeight - bottomMargin + 20;

                ctx.fillText(text, textX, textY);
            }
        }

        /**
         * colIndex(0-based) ì— í•´ë‹¹í•˜ëŠ” ê²½ë¡œì˜ ëª¨ë“  ì¢Œí‘œë¥¼ ê³„ì‚°í•´ì„œ ë°˜í™˜
         * - [ { x, y }, { x, y }, ... ] í˜•íƒœ
         * - ë§¨ ìœ„( y=0 )ë¶€í„° â†’ ê°€ë¡œì¤„/ì„¸ë¡œì¤„ â†’ ë§¨ ì•„ë˜( y=canvasHeight )
         */
        function getPathPoints(colIndex) {
            const points = [];
            const usableHeight = canvasHeight - topMargin - bottomMargin;
            const gapY = usableHeight / (rowCount + 1);
            const gapX = canvasWidth / (verticalCount + 1);

            // í˜„ì¬ ì„¸ë¡œì¤„ colIndex
            let c = colIndex;

            // ì‹œì‘ X/Y
            let currentX = gapX * (c + 1);
            let currentY = topMargin;  // ê¼­ëŒ€ê¸°ê°€ ì•„ë‹ˆë¼ topMargin ì§€ì ì—ì„œ ì‹œì‘

            // ì²« ì 
            points.push({x: currentX, y: currentY});

            // rowCountê°œì˜ 'í–‰'ì„ ë”°ë¼ ë‚´ë ¤ê°€ë©° ì¢Œìš° ì´ë™
            for (let r = 0; r < rowCount; r++) {
                const nextY = topMargin + gapY * (r + 1);
                // 1) ì„¸ë¡œë¡œ ë‚´ë ¤ê°€ê¸°
                points.push({x: currentX, y: nextY});

                // 2) ê°€ë¡œì¤„ ì²´í¬
                // ì™¼ìª½
                if (c > 0 && ladderMap[r][c - 1]) {
                    // ì™¼ìª½ ì´ë™
                    const leftX = gapX * c;
                    points.push({x: leftX, y: nextY});
                    c--;
                    currentX = leftX;
                }
                // ì˜¤ë¥¸ìª½
                else if (c < verticalCount - 1 && ladderMap[r][c]) {
                    // ì˜¤ë¥¸ìª½ ì´ë™
                    const rightX = gapX * (c + 2);
                    points.push({x: rightX, y: nextY});
                    c++;
                    currentX = rightX;
                }
            }

            // ë§¨ ì•„ë˜ê¹Œì§€
            points.push({x: currentX, y: canvasHeight - bottomMargin});

            // ìµœì¢… ë„ì°© colIndex ë°˜í™˜ë„ í•´ì•¼ í•˜ë¯€ë¡œ, c ê°’ë„ return
            return {path: points, finalCol: c};
        }

        /**
         * pathPointsë¥¼ "ì• ë‹ˆë©”ì´ì…˜"ìœ¼ë¡œ ê·¸ë¦¬ê¸°
         * - setInterval or requestAnimationFrame
         * - ë§¤ í”„ë ˆì„ë§ˆë‹¤ nextPointë¡œ ì„ ì„ ì—°ì¥
         */
        function animatePath(pathPoints, color, finalColIndex, name, result) {
            // animatingPathsì— ë“±ë¡
            animatingPaths.push({
                points: pathPoints,
                color,
                currentIndex: 0,
                finalCol: finalColIndex,
                name,
                result
            });

            // í˜¹ì‹œ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ê°€ ëŒê³  ìˆì§€ ì•Šë‹¤ë©´, ì‹œì‘
            if (!animationRunning) {
                animationRunning = true;
                requestAnimationFrame(drawAnimationFrame);
            }
        }

        // í˜„ì¬ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ë™ì‘ ì¤‘ì¸ì§€ í™•ì¸
        let animationRunning = false;

        /**
         * ëª¨ë“  ê²½ë¡œ(ì´ë¯¸ ê·¸ë ¤ì§„ + ì• ë‹ˆë©”ì´ì…˜ ì¤‘)ë¥¼ ê·¸ë¦¬ê¸° ìœ„í•´
         * ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì‹¤í–‰ë  í•¨ìˆ˜
         */
        function drawAnimationFrame() {
            // 1) ìš°ì„  ì „ì²´ Canvasë¥¼ ë‹¤ì‹œ ì´ˆê¸°í™”
            initCanvas();
            // 2) Ladder, Names, Results ë‹¤ì‹œ ê·¸ë¦¼
            drawLadder();
            drawNames(currentNameArr);
            drawResults(currentResultArr);

            // 3) ì´ë¯¸ ê·¸ë ¤ì§„ ê²½ë¡œë“¤(drawnPaths)ì€ ì¦‰ì‹œ ì „ì²´ ì„ ìœ¼ë¡œ ê·¸ë¦¼
            drawnPaths.forEach(pathObj => {
                drawFullPath(pathObj.points, pathObj.color);
            });

            // 4) ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œë“¤(animatingPaths)ì€ currentIndexê¹Œì§€ë§Œ ê·¸ë¦¼
            //    ê·¸ë¦¬ê³  currentIndexë¥¼ 1ì”© ì¦ê°€
            for (let i = 0; i < animatingPaths.length; i++) {
                const ap = animatingPaths[i];
                drawPartialPath(ap.points, ap.color, ap.currentIndex);

                // ì¸ë±ìŠ¤ ì¦ê°€ ì—ë‹ˆë©”ì´ì…˜ ì†ë„ ì¡°ì ˆ
                ap.currentIndex += 0.2;
                // ë§Œì•½ pathPoints ëê¹Œì§€ ë‹¤ ê·¸ë ¸ë‹¤ë©´, ì´ ê²½ë¡œëŠ” drawnPathsì— ì¶”ê°€
                if (ap.currentIndex >= ap.points.length) {
                    // ìµœì¢… ë„ì°© ì‹œì ì— alert (ì›ì¹˜ ì•Šìœ¼ë©´ ì£¼ì„ ì²˜ë¦¬)

                    // ì „ì²´ ê²½ë¡œë¥¼ drawnPathsì— ì¶”ê°€
                    drawnPaths.push({points: ap.points, color: ap.color});
                    // animatingPathsì—ì„œ ì œê±°
                    animatingPaths.splice(i, 1);
                    i--;
                }
            }

            // 5) ì•„ì§ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œê°€ ìˆìœ¼ë©´ ë‹¤ì‹œ requestAnimationFrame
            if (animatingPaths.length >= 0) {
                requestAnimationFrame(drawAnimationFrame);
            } else {
                // ì• ë‹ˆë©”ì´ì…˜ì´ ëª¨ë‘ ëë‚¨
                animationRunning = false;
            }
        }

        /**
         * ì´ë¯¸ ì™„ë£Œëœ ê²½ë¡œ(ì „ì²´)ë¥¼ í•œ ë²ˆì— ê·¸ë¦¬ê¸°
         */
        function drawFullPath(points, color) {
            if (!points || points.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        /**
         * ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¸ ê²½ë¡œë¥¼ í˜„ì¬ ì¸ë±ìŠ¤ê¹Œì§€ ë¶€ë¶„ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
         */
        function drawPartialPath(points, color, currentIndex) {
            if (!points || points.length < 2) return;
            if (currentIndex < 1) currentIndex = 1; // ìµœì†Œ 1ê°œ ì„ ë¶„ì€ ê·¸ë ¤ì•¼ í•¨
            if (currentIndex > points.length) currentIndex = points.length;

            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < currentIndex; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        // í˜„ì¬ ê·¸ë ¤ì§ˆ ì´ë¦„/ê²°ê³¼ ë°°ì—´ì„ ì €ì¥í•´ë‘ê³ , ë§¤ í”„ë ˆì„ë§ˆë‹¤ ê·¸ë¦¬ê¸° ìœ„í•´ ì „ì—­ì— ë³´ê´€
        let currentNameArr = [];
        let currentResultArr = [];

        /**
         * ìµœì¢… ì‹¤í–‰ í•¨ìˆ˜
         */
        function runLadderGame(nameArr, resultArr) {
            currentNameArr = nameArr;
            currentResultArr = resultArr;

            // 1) ì‚¬ë‹¤ë¦¬ ì •ë³´ ì´ˆê¸°í™”
            initLadder(nameArr.length);

            // 2) Canvas ì´ˆê¸°í™”
            initCanvas();

            // 3) ì‚¬ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
            drawLadder();

            // 4) ì´ë¦„, ê²°ê³¼ í‘œì‹œ
            drawNames(nameArr);
            drawResults(resultArr);

            // 5) í´ë¦­ ì´ë²¤íŠ¸(ì´ë¦„ í´ë¦­) ë“±ë¡
            const gameCanvas = document.getElementById('gameCanvas');
            gameCanvas.addEventListener('click', (event) => {
                const rect = gameCanvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;

                // nameBoxes í™•ì¸
                for (let box of nameBoxes) {
                    if (
                        clickX >= box.x1 && clickX <= box.x2 &&
                        clickY >= box.y1 && clickY <= box.y2
                    ) {
                        // colIndex = box.colIndex
                        // 1) ê²½ë¡œ ê³„ì‚°
                        const {path, finalCol} = getPathPoints(box.colIndex);

                        // 2) ìƒˆ ê²½ë¡œì— ëŒ€í•´ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                        //    - ìƒ‰ìƒì€ pathColorsì—ì„œ ìˆœí™˜ ì‚¬ìš© or ëœë¤
                        const color = pathColors[colorIndex % pathColors.length];
                        colorIndex++;

                        animatePath(path, color, finalCol, nameArr[box.colIndex], resultArr);

                        // ë‹¤ë¥¸ ì´ë¦„ ë°•ìŠ¤ë„ í™•ì¸ ì•ˆ í•˜ë„ë¡ ì¢…ë£Œ
                        break;
                    }
                }
            });
        }
    </script>
</div>
</body>
</html>
